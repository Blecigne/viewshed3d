data[ X < 0 , phi := (180-phi)+180] # transform phi so its range is now 0-360
# keep the data within the scene radius
data <- data[r <= scene_radius]
# build a table with all directions and the scene radius as distance
radius_tab <- data.table::data.table(phi = seq(0,360,angular_res),r = scene_radius)
if(nrow(data)>0){
# compute the minimum distance in each phi
data_radius <- data[,min(r),by = phi]
data.table::setnames(data_radius,old="V1",new="r")
# update radius_temp with the measured distances
data.table::setkey(radius_tab,phi)
data.table::setkey(data_radius,phi)
radius_tab[data_radius,r := data_radius$r]
}else{
data_radius <- data.table::data.table(phi = radius_tab$phi,r = 0)
}
########### computing area and fractal dimension of the viewshed
# transform the polar coordinates into x y coordinates
xy <- data.table::data.table(
p = pracma::deg2rad(radius_tab$phi),
t = 0,
r = radius_tab$r
)
xy <- pracma::sph2cart(as.matrix(xy))
# compute the area and perimeters of the polygon
area_vs <- pracma::polyarea(x=xy[,1],y=xy[,2])
perimeter <- pracma::poly_length(x=xy[,1],y=xy[,2])
# fractal dimension from the formula presented in eq. 20 in Chen 2020 Chen, Y.
# (2020). Two Sets of Simple Formulae to Estimating Fractal Dimension of
#Irregular Boundaries. Mathematical Problems in Engineering.
# Here I assume that the shape deviates from a circle
FD_vs <- (2*log(perimeter/(2*pi)))/log(area_vs/pi)
########### computing area and fractal dimension of the vegetation
# transform the polar coordinates into x y coordinates
xy <- data.table::data.table(
p = pracma::deg2rad(data_radius$phi),
t = 0,
r = data_radius$r
)
xy <- pracma::sph2cart(as.matrix(xy))
# compute the area and perimeters of the polygon
area <- pracma::polyarea(x=xy[,1],y=xy[,2])
perimeter <- pracma::poly_length(x=xy[,1],y=xy[,2])
# fractal dimension
FD_veg <- (2*log(perimeter/(2*pi)))/log(area/pi)
# compute visibility as a function of distance
radius_tab[,visibility := 1]
visibility <- radius_tab[order(r),.(r,visibility)]
visibility[, visibility := (1-cumsum(visibility)/(nrow(radius_tab)))*100]
# add the range 0 to minimum distance
if(min(visibility$r) > 0){
visibility <- data.table::rbindlist( list(
data.table::data.table(r= seq(0, min(visibility$r),0.1),visibility = 100),
visibility
))
}
# add the range maximum distance to scene radius
if(max(visibility$r) < scene_radius){
visibility <- data.table::rbindlist( list(
visibility,
data.table::data.table(r= seq(max(visibility$r), scene_radius,0.1),visibility = min(visibility$visibility))
))
}
radius_tab[,visibility := NULL]
# return the datasets and metrics
return(list(
visibility = visibility,
viewshed = radius_tab,
vegetation_distance = data_radius,
metrics = list(
viewshed_fractal_dimension = FD_vs,
viewshed_area = area_vs,
proportion_visible = area_vs/(pi*scene_radius^2),
viewshed_coeffecient = pracma::trapz(x = visibility$r, y = visibility$visibility),
vegetation_fractal_dimension = FD_veg
)
))
}
#- import the tree_line_plot dataset
file <- system.file("extdata", "tree_line_plot.laz", package="viewshed3d")
tls <- lidR::readLAS(file)
center <- c(0,0,2) # defines the scene center for the entire process
angle <- 1 # defines the angular resolution for the entire process
#- remove noise to avoid visibility estimates error
tls_clean <- viewshed3d::denoise_scene(tls,method="sd",
filter=6)
#- compute the horizontal visibility.
view.data <- viewshed3d::h_visibility(data = tls_clean,
position = center,
angular_res = angle,
scene_radius = 17)
# viewshed metrics
view.data$metrics
# plot the view sheds in a radial plot
plotrix::radial.plot(view.data$viewshed$r,rp.type = "p",poly.col = "blue",
radial.lim = c(0,max(view.data$viewshed$r)))
library(viewshed3d)
#- import the tree_line_plot dataset
file <- system.file("extdata", "tree_line_plot.laz", package="viewshed3d")
tls <- lidR::readLAS(file)
center <- c(0,0,2) # defines the scene center for the entire process
angle <- 1 # defines the angular resolution for the entire process
#- remove noise to avoid visibility estimates error
tls_clean <- viewshed3d::denoise_scene(tls,method="sd",
filter=6)
#- compute the horizontal visibility.
view.data <- viewshed3d::h_visibility(data = tls_clean,
position = center,
angular_res = angle,
scene_radius = 17)
# viewshed metrics
view.data$metrics
# plot the view sheds in a radial plot
plotrix::radial.plot(view.data$viewshed$r,rp.type = "p",poly.col = "blue",
radial.lim = c(0,max(view.data$viewshed$r)))
library(viewshed3d)
# generate a sphere
sph = viewshed3d::generate_sphere()
# plot the sphere
rgl::plot3d(sph)
# generate a sphere
sph = viewshed3d::generate_sphere(sph = T)
sph
library(viewshed3d)
# produce a spherical point cloud
sph = generate_sphere(angular_res = 0.1,r = 1.5)
# compute visibility without segmentation
view.data = d_visibility(data = lidR::LAS(sph),
position = c(0,0,0),
angular_res = 1,
store_points = TRUE,
scene_radius = 2)
# plot the viewshed
lidR::plot(view.data$points,colorPalette = "darkgreen")
library(viewshed3d)
# produce a spherical point cloud
sph = generate_sphere(angular_res = 0.1,r = 1.5)
# compute visibility without segmentation
view.data = d_visibility(data = lidR::LAS(sph),
position = c(0,0,0),
angular_res = 1,
store_points = TRUE,
scene_radius = 2)
# produce a spherical point cloud
sph = lidR::LAS(generate_sphere(angular_res = 0.1,r = 1.5))
# compute visibility without segmentation
view.data = d_visibility(data = sph,
position = c(0,0,0),
angular_res = 1,
store_points = TRUE,
scene_radius = 2)
# plot the viewshed
lidR::plot(view.data$points,colorPalette = "darkgreen")
# compute visibility segmented by elevation
view.data = d_visibility(data = sph,
position = c(0,0,0),
angular_res = 1,
store_points = TRUE,
scene_radius = 2,
elevation_range = c(80,100))
# plot the viewshed
lidR::plot(view.data$points,colorPalette = "darkgreen")
# compute visibility segmented by azimuth
view.data = d_visibility(data = sph,
position = c(0,0,0),
angular_res = 1,
store_points = TRUE,
scene_radius = 2,
azimuth_range = c(85,105))
# plot the viewshed
lidR::plot(view.data$points,colorPalette = "darkgreen")
# compute visibility segmented by azimuth and elevation
view.data = d_visibility(data = sph,
position = c(0,0,0),
angular_res = 1,
store_points = TRUE,
scene_radius = 2,
azimuth_range = c(350,10),
elevation_range = c(80,100))
# plot the viewshed
lidR::plot(view.data$points,colorPalette = "darkgreen")
#- import the tree_line_plot dataset
file <- system.file("extdata", "tree_line_plot.laz", package="viewshed3d")
tls <- lidR::readLAS(file,select="xyz")
#- reduce the point cloud density: keep one point in a voxel of 4cm.
sub = viewshed3d::downsample_scene(tls,filter=0.04)
#- plot the downsampled point cloud
lidR::plot(sub)
#- reduce the point cloud density: keep one point in a voxel of 4cm.
sub = viewshed3d::downsample_scene(tls,filter=0.24)
#- plot the downsampled point cloud
lidR::plot(sub)
#- import the tree_line_plot dataset
file <- system.file("extdata", "tree_line_plot.laz", package="viewshed3d")
tls <- lidR::readLAS(file,select="xyz")
#- class ground and vegetation points
class <- lidR::classify_ground(tls, lidR::csf(rigidness = 1L,
class_threshold = 0.2,
sloop_smooth = FALSE))
#- reconstruct the ground. Here the ground is reconstructed with the user
#- defined resolution only.
recons <- viewshed3d::reconstruct_ground(data=class,position = c(0,0,3),
ground_res = 0.05,
angular_res = 2,
method="knnidw")
lidR::plot(recons,color="Classification",
colorPalette = c("darkgreen","chocolate4"))
#- when the position is closer to the ground, the user defined resolution is
#- not sufficient and a second grid is added with the optimal resolution so
#- that no sightline can pass trough the ground when computing visibility.
#- In this example, full_raster = TRUE was used as a portion of the ground
#- near the animal location is not reconstructed because of a data
#- gap around a TLS scan position when using full_raster = FALSE.
recons <- viewshed3d::reconstruct_ground(data=class,position = c(0,0,1),
ground_res = 0.05,
angular_res = 2,
method="knnidw",
full_raster = TRUE)
lidR::plot(recons,color="Classification",
colorPalette = c("darkgreen","chocolate4"))
lidR::grid_terrain(pkgcond::suppress_messages(tls),
ground_res,
lidR::knnidw(...),
full_raster = TRUE)
lidR::grid_terrain(pkgcond::suppress_messages(tls),
1,
lidR::knnidw(...),
full_raster = TRUE)
lidR::grid_terrain(pkgcond::suppress_messages(tls),
1,
lidR::knnidw(),
full_raster = TRUE)
lidR::grid_terrain(pkgcond::suppress_messages(class),
1,
lidR::knnidw(),
full_raster = TRUE)
library(viewshed3d)
#- import the tree_line_plot dataset
file <- system.file("extdata", "tree_line_plot.laz", package="viewshed3d")
tls <- lidR::readLAS(file,select="xyz")
#- class ground and vegetation points
class <- lidR::classify_ground(tls, lidR::csf(rigidness = 1L,
class_threshold = 0.2,
sloop_smooth = FALSE))
#- reconstruct the ground. Here the ground is reconstructed with the user
#- defined resolution only.
recons <- viewshed3d::reconstruct_ground(data=class,position = c(0,0,3),
ground_res = 0.05,
angular_res = 2,
method="knnidw")
lidR::plot(recons,color="Classification",
colorPalette = c("darkgreen","chocolate4"))
data=class
data <- data@data[,.(X,Y,Z,Classification)] # transform data into a data.table
vegetation=data[Classification == 1]
ground=data[Classification == 2]
#- compute the ground points distance to the animal location
ground[,r := sqrt((X-position[1])^2+(Y-position[2])^2+(Z-position[3])^2)]
position <- c(0,0,0)
ground_res <- 0.05
angular_res <- 1
method <- "knnidw"
full_raster <- F
#- compute the ground points distance to the animal location
ground[,r := sqrt((X-position[1])^2+(Y-position[2])^2+(Z-position[3])^2)]
scene_radius <- sqrt((ground$X-position[1])^2+(ground$Y-position[2])^2)
scene_radius <- max(scene_radius,na.rm=T)
#- compute the required ground resolution based on distance to location and
#- angular_resolution so that no sightline can pass trough the ground when
#- using the visibility() function
distances  <-  seq(min(ground[,r]),max(ground[,r]),0.1) #- range of distance
#- the required ground resolution at each distance
spacing  <-  (distances*tan(pracma::deg2rad(angular_res)))/1.5
if(min(spacing)<ground_res){
#- the portion of the ground where finest reconstruction is needed
ground.fine.recons  <- ground[r<=distances[min(which(spacing>=ground_res))]]
}
#- renconstruct the ground with the user defined resolution and then,
#- if needed, with the calculated fine resolution using the lidR package tools
if(method == "knnidw"){
#- reconstruct the ground for the entire plot
dtm.all <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
lidR::knnidw(...),
full_raster = TRUE))
if(min(spacing)<ground_res){
#- reconstruct the portion of the ground that require a fine
#- reconstruction with the parameters calculated previously
dtm.fine <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground.fine.recons[,1:4]),
min(spacing),
lidR::knnidw(...),
full_raster=full_raster))
}
}
#- renconstruct the ground with the user defined resolution and then,
#- if needed, with the calculated fine resolution using the lidR package tools
if(method == "knnidw"){
#- reconstruct the ground for the entire plot
dtm.all <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
lidR::knnidw(),
full_raster = TRUE))
if(min(spacing)<ground_res){
#- reconstruct the portion of the ground that require a fine
#- reconstruction with the parameters calculated previously
dtm.fine <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground.fine.recons[,1:4]),
min(spacing),
lidR::knnidw(...),
full_raster=full_raster))
}
}
#- renconstruct the ground with the user defined resolution and then,
#- if needed, with the calculated fine resolution using the lidR package tools
if(method == "knnidw"){
#- reconstruct the ground for the entire plot
dtm.all <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
lidR::knnidw(),
full_raster = TRUE))
if(min(spacing)<ground_res){
#- reconstruct the portion of the ground that require a fine
#- reconstruction with the parameters calculated previously
dtm.fine <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground.fine.recons[,1:4]),
min(spacing),
lidR::knnidw(),
full_raster=full_raster))
}
}
pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
lidR::knnidw(),
full_raster = TRUE))
pkgcond::suppress_messages(dtm.all <- lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
lidR::knnidw(),
full_raster = TRUE))
#- reconstruct the ground for the entire plot
pkgcond::suppress_messages(dtm.all <- lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
pkgcond::suppress_messages(lidR::knnidw()),
full_raster = TRUE))
#- reconstruct the ground for the entire plot
dtm.all <- lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
pkgcond::suppress_messages(lidR::knnidw()),
full_raster = TRUE)
#- reconstruct the ground for the entire plot
pkgcond::suppress_warnings(dtm.all <- lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
pkgcond::suppress_messages(lidR::knnidw()),
full_raster = TRUE))
#- renconstruct the ground with the user defined resolution and then,
#- if needed, with the calculated fine resolution using the lidR package tools
pkgcond::suppress_warnings(pkgcond::suppress_messages(
if(method == "knnidw"){
#- reconstruct the ground for the entire plot
dtm.all <- lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
lidR::knnidw(),
full_raster = TRUE)
if(min(spacing)<ground_res){
#- reconstruct the portion of the ground that require a fine
#- reconstruction with the parameters calculated previously
dtm.fine <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground.fine.recons[,1:4]),
min(spacing),
lidR::knnidw(),
full_raster=full_raster))
}
}
if(method == "tin"){
#- reconstruct the ground for the entire plot
dtm.all <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
lidR::tin(...),
full_raster = TRUE))
if(min(spacing)<ground_res){
#- reconstruct the portion of the ground that require a fine
#- reconstruction with the parameters calculated previously
dtm.fine = pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground.fine.recons[,1:4]),
min(spacing),
lidR::tin(...),
full_raster=full_raster))
}
}
if(method == "kriging"){
#- reconstruct the ground for the entire plot
dtm.all <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
lidR::kriging(...),
full_raster = TRUE))
if(min(spacing)<ground_res){
#- reconstruct the portion of the ground that require a fine
#- reconstruction with the parameters calculated previously
dtm.fine <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground.fine.recons[,1:4]),
min(spacing),
lidR::kriging(...),
full_raster=full_raster))
}
}
))
#- renconstruct the ground with the user defined resolution and then,
#- if needed, with the calculated fine resolution using the lidR package tools
pkgcond::suppress_warnings(pkgcond::suppress_messages(
if(method == "knnidw"){
#- reconstruct the ground for the entire plot
dtm.all <- lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
lidR::knnidw(),
full_raster = TRUE)
if(min(spacing)<ground_res){
#- reconstruct the portion of the ground that require a fine
#- reconstruction with the parameters calculated previously
dtm.fine <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground.fine.recons[,1:4]),
min(spacing),
lidR::knnidw(),
full_raster=full_raster))
}
}
if(method == "tin"){
#- reconstruct the ground for the entire plot
dtm.all <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
lidR::tin(...),
full_raster = TRUE))
if(min(spacing)<ground_res){
#- reconstruct the portion of the ground that require a fine
#- reconstruction with the parameters calculated previously
dtm.fine = pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground.fine.recons[,1:4]),
min(spacing),
lidR::tin(...),
full_raster=full_raster))
}
}
if(method == "kriging"){
#- reconstruct the ground for the entire plot
dtm.all <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
lidR::kriging(...),
full_raster = TRUE))
if(min(spacing)<ground_res){
#- reconstruct the portion of the ground that require a fine
#- reconstruction with the parameters calculated previously
dtm.fine <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground.fine.recons[,1:4]),
min(spacing),
lidR::kriging(...),
full_raster=full_raster))
}
}
))
#- renconstruct the ground with the user defined resolution and then,
#- if needed, with the calculated fine resolution using the lidR package tools
pkgcond::suppress_conditions(
if(method == "knnidw"){
#- reconstruct the ground for the entire plot
dtm.all <- lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
lidR::knnidw(),
full_raster = TRUE)
if(min(spacing)<ground_res){
#- reconstruct the portion of the ground that require a fine
#- reconstruction with the parameters calculated previously
dtm.fine <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground.fine.recons[,1:4]),
min(spacing),
lidR::knnidw(),
full_raster=full_raster))
}
}
if(method == "tin"){
#- reconstruct the ground for the entire plot
dtm.all <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
lidR::tin(...),
full_raster = TRUE))
if(min(spacing)<ground_res){
#- reconstruct the portion of the ground that require a fine
#- reconstruction with the parameters calculated previously
dtm.fine = pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground.fine.recons[,1:4]),
min(spacing),
lidR::tin(...),
full_raster=full_raster))
}
}
if(method == "kriging"){
#- reconstruct the ground for the entire plot
dtm.all <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
lidR::kriging(...),
full_raster = TRUE))
if(min(spacing)<ground_res){
#- reconstruct the portion of the ground that require a fine
#- reconstruction with the parameters calculated previously
dtm.fine <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground.fine.recons[,1:4]),
min(spacing),
lidR::kriging(...),
full_raster=full_raster))
}
}
)
method
pkgcond::suppress_conditions(
dtm.all <- lidR::grid_terrain(lidR::LAS(ground[,1:4]),
ground_res,
lidR::knnidw(),
full_raster = TRUE)
if(min(spacing)<ground_res){
#- reconstruct the portion of the ground that require a fine
#- reconstruction with the parameters calculated previously
dtm.fine <- pkgcond::suppress_messages(lidR::grid_terrain(lidR::LAS(ground.fine.recons[,1:4]),
min(spacing),
lidR::knnidw(),
full_raster=full_raster))
})
